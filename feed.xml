<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Xtt's Blog</title>
    <link href="" rel="self" />
    <link href="http://xuting.me/" />
    <updated>2016-03-30T20:00:00Z</updated>
    <id>http://xuting.me/</id>
    
    <entry>
        <title><![CDATA[css之图像替换]]></title>
        <author><name>xtt</name><uri>http://xuting.me/</uri></author>
        <link href="http://xuting.me/css_image_replace/"/>
        <updated>2016-03-30T20:00:00Z</updated>
        <published>2016-03-30T20:00:00Z</published>
        <id>http://xuting.me/css_image_replace/</id>
        <content type="html">
            <![CDATA[
             <h3>一.概念</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;图像替代，就是像我们在平时将文本添加到文本中，然后通过css隐藏文本在它的位置上显示一个背景图片，这样，搜索引擎仍然可以搜到HTML文本，即使我们禁用css后，文本时仍然是可以显示的。<br><br/>
引用《精通css》中的一段解释：  </p>

<blockquote>
<p>HTML文本由很多的优点。文本可以被搜索引擎读取，开发人员可以对其进行复制和粘贴，并且在浏览器中改变字体大小后，它也会改变。因此很多设计人员都想尽量的采用HTML文本而不是文本的图像，但是遗憾的是，页面设计人员对于文本有有限的选择，尽管可以通过css来控制版面但是有很多字体的效果是无法实现的，所以在某些情况下还是需要用文本的图像的。 图像替代，就是像我们在平时将文本添加到文本中，然后通过css隐藏文本在它的位置上显示一个背景图片，这样，搜索引擎仍然可以搜到HTML文本，即使我们禁用css后，文本时仍然是可以显示的。  </p>
</blockquote>

<p>引用《CSS禅意花园》中的一段解释：  </p>

<blockquote>
<p>图像替换技术使用display:none的本意并不只是想要替换文本，这样做还有一些更深层次的理由。实际上，若是没有任何提示或帮助，计算机就无法认出或读取图像中包含的文字。例如HTML中img元素，若是没有了alt属性，那么对于google等搜索引擎，以及辅助浏览设备（例如，屏幕阅读器即可阅读页面内容，并以声音的形式告诉浏览者）之类无法呈现图像的客户端来说，将变的豪无意义。而图像替换技术则保留了被替换元素中的原有文本，因此无论对任何客户而言，理解页面内容都不成问题。  </p>
</blockquote>

<h3>二.图像替换实现方法</h3>

<h4>1.经典FIR，设法隐藏文字内容：（Fahrner Image Replacement）</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;最早开始流行的图像替换技术，也最容易理解，但是存在一些可访问性问题所依应该避免使用。<br>  </p>

<p>(1)把要替换的文本放在span标签中:<br>  </p>

<blockquote>
<p>&lt;h2&gt;<br/>
  &lt;span&gt;Hello World &lt;span&gt;<br/>
&lt;/h2&gt;  </p>
</blockquote>

<p>(2)然后将替换图像作为背景应用于文本元素,<br>  </p>

<blockquote>
<p>h2{<br><br/>
&nbsp;&nbsp;&nbsp;&nbsp;background:url(替换图片.gif) no-repeat;<br><br/>
&nbsp;&nbsp;&nbsp;&nbsp;width: 150px;<br><br/>
&nbsp;&nbsp;&nbsp;&nbsp;height: 35px;<br><br/>
}  </p>
</blockquote>

<p>(3)将span的display设置为none，从而隐藏span的内容。<br>  </p>

<blockquote>
<p>span{<br><br/>
&nbsp;&nbsp;&nbsp;&nbsp;display:none;<br><br/>
}  </p>
</blockquote>

<p>存在问题：  </p>

<blockquote>
<p>许多流行的屏幕阅读器会忽略那些display：none和visibility：hidden的元素，因为会完全忽略这个文本，造成严重的访问问题。  </p>
</blockquote>

<h4>2.设置边距或缩进将文字弹走：Phark</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp; 不需要添加无语义的标签，也不需要使用display属性来隐藏文本，只需要对需要替换的文字进行非常大的负值首行所进。  </p>

<blockquote>
<p>&lt;h2&gt;<br/>
  Hello World<br/>
&lt;/h2&gt;<br><br/>
 h2{<br><br/>
&nbsp;&nbsp;&nbsp;&nbsp;width: 150px;<br><br/>
&nbsp;&nbsp;&nbsp;&nbsp;height: 35px;<br><br/>
&nbsp;&nbsp;&nbsp;&nbsp;text-indent:-5000px;(非常大的负值首行所进)<br><br/>
&nbsp;&nbsp;&nbsp;&nbsp;background:url(替换图片.gif) no-repeat;<br><br/>
}  </p>
</blockquote>

<p>&nbsp;&nbsp;&nbsp;&nbsp;这个方法很好的解决了屏幕阅读器的问题，但是在关闭图像仍然打开css的情况下是无效的，虽然这种情况比较小，在网速访问非常慢的情况下或者访问者能够打开图像但是设置不打开，这些情况下一些人是看不到被替换的文本的。  </p>

<h4>3.Leahy和Langridge方法</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;该方法不必再添加那些多余的<span>标签，且在保证屏幕阅读器可以正常阅读文本的同时，也能在页面中隐藏元素中的内容。但是并没有解决浏览器禁用图象后空白页面的可访问性问题。  </p>

<blockquote>
<p>&lt;h2&gt;<br/>
  Hello World<br/>
&lt;/h2&gt;<br><br/>
 h2{<br><br/>
&nbsp;&nbsp;&nbsp;&nbsp;height:0;<br><br/>
&nbsp;&nbsp;&nbsp;&nbsp;padding:30px 0 0 0;<br><br/>
&nbsp;&nbsp;&nbsp;&nbsp;overflow:hidden;<br><br/>
&nbsp;&nbsp;&nbsp;&nbsp;background:url(替换图片.gif) no-repeat;<br><br/>
}  </p>
</blockquote>

<h4>4.用额外元素覆盖住文字：Levin方法</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;Levin Alexander想出了一个绝妙的注意：不再将文本置放于span中，而是将其从span中移出来，将文本和span一起放在父元素中，然后使用这个空白的span覆盖文本，并将背景图像应用到span之上。繁琐的代码下，终于完美的解决了关闭图像打开CSS问题，但新的问题也随之出现，那就是图像不能是透明的，否则用户将会看到下面的文本。除此之外，文字内容没有被直接包含于任何节点之内，可能会给前端开发带来意想不到的麻烦。  </p>

<blockquote>
<p>&lt;h3 class=&ldquo;replace&rdquo; id=&ldquo;myh1&rdquo;&gt;And a dash of Thyme.&lt;span&gt;&lt;/span&gt;&lt;/h3&gt;  </p>

<p>.replace{<br><br/>
&nbsp;&nbsp;&nbsp;&nbsp;position:relative;<br><br/>
&nbsp;&nbsp;&nbsp;&nbsp;margin:0;<br><br/>
&nbsp;&nbsp;&nbsp;&nbsp;padding:0;<br><br/>
}<br><br/>
.replace span{<br><br/>
&nbsp;&nbsp;&nbsp;&nbsp;display:block;<br><br/>
&nbsp;&nbsp;&nbsp;&nbsp;position:absolute;<br><br/>
&nbsp;&nbsp;&nbsp;&nbsp;top:0;<br><br/>
&nbsp;&nbsp;&nbsp;&nbsp;left:0;<br><br/>
&nbsp;&nbsp;&nbsp;&nbsp;z-index:1;<br><br/>
}<br><br/>
/#myh1,#myh1 span{<br><br/>
&nbsp;&nbsp;&nbsp;&nbsp;height:25px;<br><br/>
&nbsp;&nbsp;&nbsp;&nbsp;width:300px;<br><br/>
&nbsp;&nbsp;&nbsp;&nbsp;background:url(替换图像.png);<br><br/>
}<br>  </p>
</blockquote>

<h4>五.基于flash和javascript：sFIR</h4>

<p>Mike Davidson和Shaun Inman提出了一种新的iFIR技术。该方法使用JavaScript搜索文<br/>
档中特定节点，将其中的内容替换成一小段Flash。<br><br/>
引用《精通css》d对这一技术的介绍：  </p>

<blockquote>
<p>Flash允许将字体嵌入SWF文件，所以他们并不把文本换成图像，而是用Flash文件替换文本。进行这一替换的方法是使用JavaScript搜索文档，找到特定元素或者具有特定类名的元素中的所有文本。然后JavaScript将文本替换为一个小的Flash文件。接下来是真正精明的部分。这种技术并不为每段文本创建单独的Flash文件，而是将被替换的文本放回一个重复的Flash文件中。因此，触发图像替换所要做的只是添加一个类，Flash和JavaScript会完成余下的工作。另一个好处是Flash文件中的文本是可搜索的，这意味着可以轻松地复制它。  </p>
</blockquote>

<p>&nbsp;&nbsp;&nbsp;&nbsp;存在问题：使用Flash替代的缺点在于改方法要求JavaScript和Flash支持，并且Flash会远大于一副普通图片，下载时会造成延迟，在较慢的电脑上页面会出现闪烁甚至停滞。  </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;就目前来讲没有最完美的图像替换方法，但是可以用最小的代价换取效果。例如，在移动设备上可以用Levin的方法，因为一般移动设备商不会使用透明图片。而在国内，屏幕阅读器还没普及的情况下，牺牲屏幕阅读器也是可以考虑的。  </p>

            ]]>
        </content>
    </entry>
    
    <entry>
        <title><![CDATA[关于浮动与清除浮动]]></title>
        <author><name>xtt</name><uri>http://xuting.me/</uri></author>
        <link href="http://xuting.me/css_float/"/>
        <updated>2016-02-23T21:00:00Z</updated>
        <published>2016-02-23T21:00:00Z</published>
        <id>http://xuting.me/css_float/</id>
        <content type="html">
            <![CDATA[
             <blockquote>
<p>在css布局中常用的一个属性就是float，它可以让div块脱离原本的文档流向左或向右浮动，但是&hellip;这个浮动有时候很烦，需要清除浮动，下面详细整理一下关于浮动，为什么要清除浮动和怎样清除浮动。  </p>
</blockquote>

<h3>一. float</h3>

<blockquote>
<p>float浮动样式没有靠中（浮动居中）的样式，在css布局中如果需要让标签对象居中需要margin等其它方法（先偷懒下次整理(●°u°●)​ ），这里记住浮动靠右使用float:right，浮动靠左使用float:left样式即可。例子到下面一起举。  </p>
</blockquote>

<h3>二.为什么要清除浮动？</h3>

<blockquote>
<p>div嵌套式子元素浮动而父元素未浮动<br><br/>
后果：因为float会脱离文档流，这样就导致了父元素的height为0.  </p>
</blockquote>

<p><img src="http://7xpt78.com1.z0.glb.clouddn.com/float1.png">  </p>

<blockquote>
<p>此时父元素div的height变为0，只显示了3px的边框：  </p>
</blockquote>

<p><img src="http://7xpt78.com1.z0.glb.clouddn.com/float2.png" width="520px">  </p>

<h3>三.如何清除浮动？</h3>

<h4>（第一类）：在元素末尾添加一个内容带有clear：both属性的空元素</h4>

<blockquote>
<p>1.方法一：使用带clear属性的空元素  </p>
</blockquote>

<p><img src="http://7xpt78.com1.z0.glb.clouddn.com/float3.png">  </p>

<blockquote>
<p>在在浮动元素的下面加了一个clear：both；的属性，然后浮动被清除，父元素的高度被自动填充了：  </p>
</blockquote>

<p><img src="http://7xpt78.com1.z0.glb.clouddn.com/float4.png" width="500px">  </p>

<blockquote>
<p>2.方法二：使用CSS的:after伪元素  </p>
</blockquote>

<p><img src="http://7xpt78.com1.z0.glb.clouddn.com/float5.png" width="500px" >  </p>

<blockquote>
<p>给浮动元素的容器添加一个clearfix的class，然后给这个class添加一个:after伪元素实现元素末尾添加一个看不见的块元素（Block element）清理浮动。需要注意的是为了IE6和IE7浏览器，要添加一条zoom:1;触发haslayout。  </p>
</blockquote>

<p><img src="http://7xpt78.com1.z0.glb.clouddn.com/float6.png" width="500px">  </p>

<h4>(第二类)：触发浮动元素父元素的 BFC (Block Formatting Contexts, 块级格式化上下文)，使到该父元素可以包含浮动元素</h4>

<blockquote>
<p>3.方法三：使用CSS的overflow属性  </p>
</blockquote>

<p><img src="http://7xpt78.com1.z0.glb.clouddn.com/float7.png">  </p>

<blockquote>
<p>给浮动元素的容器添加overflow:hidden;或overflow:auto;可以清除浮动，另外在 IE6 中还需要触发 hasLayout ，例如为父元素设置容器宽高或设置 zoom:1。  </p>
</blockquote>

<p><img src="http://7xpt78.com1.z0.glb.clouddn.com/float4.png" width="500px">  </p>

<blockquote>
<p>4.方法四：给浮动的元素的容器添加浮动(但是这样会使其整体浮动，影响布局，不推荐使用. )  </p>
</blockquote>

<p><img src="http://7xpt78.com1.z0.glb.clouddn.com/float8.png">  </p>

<blockquote>
<p>显示结果与方法三相同就不再列出。  </p>
</blockquote>

<h4>四.后记</h4>

<blockquote>
<p>网上推荐说在网页主要布局时使用:after伪元素方法并作为主要清理浮动方式；在小模块如ul里使用overflow:hidden;如果本身就是浮动元素则可自动清除内部浮动，无需格外处理；正文中使用邻接元素清理之前的浮动。回顾一下洗洗睡觉(●°u°●)​ 」  </p>
</blockquote>

            ]]>
        </content>
    </entry>
    
    <entry>
        <title><![CDATA[css定位机制]]></title>
        <author><name>xtt</name><uri>http://xuting.me/</uri></author>
        <link href="http://xuting.me/css_position/"/>
        <updated>2016-02-19T14:00:00Z</updated>
        <published>2016-02-19T14:00:00Z</published>
        <id>http://xuting.me/css_position/</id>
        <content type="html">
            <![CDATA[
             <blockquote>
<p>每次用div＋css布局的时候都混乱的不行，所以决定仔细梳理一遍，加强理解和记忆<sup><sup>。</sup></sup>  </p>
</blockquote>

<h3>一.文档流是什么？</h3>

<p>&nbsp;&nbsp;&nbsp;&nbsp;CSS 有三种基本的定位机制：普通流、浮动和绝对定位。除非专门指定，否则所有框都在普通流中定位。块级框从上到下一个接一个地排列，框之间的垂直距离是由框的垂直外边距计算出来。行内框在一行中水平布置。可以使用水平内边距、边框和外边距调整它们的间距。但是，垂直内边距、边框和外边距不影响行内框的高度。<br><br/>
&nbsp;&nbsp;&nbsp;&nbsp;“文档“”就是网页的页面，doctype；“流”就是指页面上的元素输入输出的形式和顺序，其中“输入”是布局，输出是“显示”；综合起来就是：页面布局＋显示的形式。<br>  </p>

<h3>二.position详解</h3>

<blockquote>
<p>在css中，通过position属性，配合top,right,left,buttom对元素进行定位。<br><br/>
position属性有：static，relative，absolute，fixed,下面来详细分析：  </p>
</blockquote>

<h4>1.默认定位：static</h4>

<blockquote>
<p>块元素相对于浏览器布局，一行一个，自动换行。  </p>
</blockquote>

<p><img src="http://7xpt78.com1.z0.glb.clouddn.com/static.png" alt="static" width="400px" height="450px"/>  </p>

<blockquote>
<p>显示结果：  </p>
</blockquote>

<p><img src="http://7xpt78.com1.z0.glb.clouddn.com/static1.png" alt="static" width="300px" height="240px"/>  </p>

<h4>2.相对定位：relative</h4>

<blockquote>
<p>相对定位就应该是相对于一个东西来定位，而这个东西就是元素自己本身，用left right top b0ttom进行定位后，元素会根据原来的位置进行移动，但由于position:relative这个属性并没有脱离文档流的，所以元素本身所占的位置会保留。  </p>
</blockquote>

<ul>
<li> 现在我给第二个块加上一个样式：<br/></li>
</ul>

<p><img src="http://7xpt78.com1.z0.glb.clouddn.com/relative.png" alt="static" width="250px" height="120px"/>  </p>

<blockquote>
<p>显示结果：<br/>
块二通过position:relative相对于原来的位置左移50px; 上移20px得到的，而且块三并没有因为块二的上移而上移，原因就是position:relative这个属性是没有脱离文档流的，所以元素本身所占的位置会保留。  </p>
</blockquote>

<p><img src="http://7xpt78.com1.z0.glb.clouddn.com/relative1.png" alt="static" width="300px" height="200px"/>  </p>

<h4>3.绝对定位：absolute</h4>

<blockquote>
<p>所谓绝对定位，其实也是相对于某个东西来绝对定位，而这个东西就是靠元素的最近的一个有position，且positon不能为static的祖先元素，一般来说是position为relative的父级元素，如果没有，则相对于body定位；值得注意的是position:absolute这个属性是脱离文档流的，所以重新定位后元素是不会占着原来的位置的，从原来的文档中分离被孤立了出来。  </p>
</blockquote>

<ul>
<li>现在我再修改一下代码，将dad父元素的position设置为relative，块二的position设置为absolute：<br/></li>
</ul>

<p><img src="http://7xpt78.com1.z0.glb.clouddn.com/absolute.png" alt="static" width="400px" height="500px"/>  </p>

<blockquote>
<p>显示结果：块二相对于dad块下边界20px，相对于dad块左边界50px；而块三向上移动占据了本来属于块二的位置，原因在于position:absolute这个属性是脱离文档流的，所以重新定位后元素是不会占着原来的位置的，从原来的文档中分离被孤立了出来。  </p>
</blockquote>

<p><img src="http://7xpt78.com1.z0.glb.clouddn.com/absolute1.png" alt="static" width="300px" height="300px"/>  </p>

<h4>4.固定定位：fixed</h4>

<blockquote>
<p>元素框的表现类似于将 position 设置为 absolute，不过其包含块是视窗本身,它的位置始终相对于窗口，可以实现固定导航栏的效果，也这意味着即便页面滚动，它还是会停留在相同的位置， top 、 right 、 bottom 和 left 属性都可用。  </p>
</blockquote>

            ]]>
        </content>
    </entry>
    
    <entry>
        <title><![CDATA[Dom事件探秘]]></title>
        <author><name>xtt</name><uri>http://xuting.me/</uri></author>
        <link href="http://xuting.me/domEvent/"/>
        <updated>2016-01-19T17:30:00Z</updated>
        <published>2016-01-19T17:30:00Z</published>
        <id>http://xuting.me/domEvent/</id>
        <content type="html">
            <![CDATA[
             <h3>一.理解事件流</h3>

<h4>1.含义：</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;描述的是从页面中接受事件的顺序.  </p>

<h4>2. 事件冒泡</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;描述事件冒泡，即事件最开始由最具体的元素(文档中嵌套层次最深的那个节点)接收，然后逐级向上转播至最不具体的节点(文档)。（IE,chrom,火狐等大部分浏览器使用）  </p>

<h4>3.事件捕获</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;描述事件捕获的思想是不太具体的节点应该更早接收到事件，而最具体的节点最后接收到事件。（Netscape的事件流是事件捕获流）  </p>

<hr/>

<h3>二.使用事件处理程序</h3>

<h4>1.HTML事件处理程序</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;在html结构中直接写入事件处理程序，缺点时html和js耦合太紧密，很难修改。  </p>

<pre><code>&lt;input type=&quot;button&quot; value=&quot;按钮&quot; id=&quot;btn&quot; onclick=&quot;alert(&#39;hello&#39;)&quot;&gt;</code></pre>

<h4>2.Dom0级事件处理程序</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;方法：函数赋值 element.onclick=function()（只能为一个元素添加一个事件处理函数）  </p>

<pre><code>var btn2=document.getElementById(&#39;btn2&#39;);  
 btn2.onclick=function(){  
    alert(&#39;这是通过Dom0级添加的事件！&#39;);  
 }</code></pre>

<h4>3.Dom2级事件处理程序</h4>

<pre><code>var btn3=document.getElementById(&#39;btn3&#39;);  

 btn3.addEventListener(&#39;click&#39;,showMes,false);  
 btn3.removeEventListener(&#39;click&#39;,showMes,false);</code></pre>

<ul>
<li>element.addEventLIistener()：添加事件，必须用removeEventListener删除<br/></li>
<li>element.removeEventListener()：删除事件，参数必须与addEventListener  相同<br/></li>
<li>上述两个方法接受3个参数：要处理的事件类型（不加on），作为事件处理程序的函数和布尔值<br/></li>
<li>Dom0heDom2可以在一个节点元素上添加多个事件<br/></li>
</ul>

<h4>4.IE事件处理程序</h4>

<ul>
<li>element.attachEvent()：添加事件<br/></li>
<li>element.detachEvent()：删除事件<br/></li>
<li>接受两个参数：要处理的事件类型type（要加on）和事件处理程序函数，不使用布尔值是因为IE8及更早的版本只支持实事件冒泡（语法注意： .等价于［］）<br/></li>
</ul>

<p>前四种事件处理程序代码截图如下：  </p>

<p><img src="http://7xpt78.com1.z0.glb.clouddn.com/dom2.png" width="400" height="400" alt="dom1" align=center/>  </p>

<h4>5.跨浏览器的的事件处理程序</h4>

<ul>
<li>把能力测试函数封装到单独的变量对象中（可以单独存在一个文件中留以后备用）<br/>
<img src="http://7xpt78.com1.z0.glb.clouddn.com/dom.png" width="350" height="400" alt="dom2" align=center /><br/></li>
</ul>

<hr/>

<h3>三.事件对象</h3>

<h4>1.Dom 中事件对象</h4>

<ul>
<li>.type属性：获取事件属性<br/></li>
<li>.target属性：获取事件目标<br/></li>
<li>.stopPropagation()方法用于阻止事件冒泡<br/></li>
<li>.preventDefault()方法阻止默认行为<br/></li>
</ul>

<h4>2.IE中的事件对象</h4>

<ul>
<li>.type属性：获取事件属性<br/></li>
<li>.srcElement属性:获取事件目标<br/></li>
<li>.cancelBubblE属性:用于阻止事件冒泡，true表示阻止冒泡，false不阻止冒泡表示<br/></li>
<li>.returnValue 属性：用于阻止事件的默认行为，设置false表示阻止事件的默认行为<br/></li>
</ul>

<p><img src="http://7xpt78.com1.z0.glb.clouddn.com/dom3.png" width="200" heigh="150" alt="dom3" align=center />  </p>

<h4>3.浏览器兼容问题</h4>

<ul>
<li>根据能力判断将函数封装到单独的变量中(类似上一节二.5)<br/></li>
</ul>

<h5>4.<a href="https://github.com/Evaxtt/study/blob/master/Dom%E4%BA%8B%E4%BB%B6%E6%8E%A2%E7%A7%98/Dom%E4%BA%8B%E4%BB%B6%E6%8E%A2%E7%A7%98.xmind" title="dom思维导图笔记">Dom事件思维导图笔记</a></h5>

            ]]>
        </content>
    </entry>
    
    <entry>
        <title><![CDATA[常见正则表达式使用]]></title>
        <author><name>xtt</name><uri>http://xuting.me/</uri></author>
        <link href="http://xuting.me/RegularExpression/"/>
        <updated>2016-01-12T14:00:00Z</updated>
        <published>2016-01-12T14:00:00Z</published>
        <id>http://xuting.me/RegularExpression/</id>
        <content type="html">
            <![CDATA[
             <h2>正则表达式是什么？</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。</br><br/>
&nbsp;&nbsp;&nbsp;&nbsp;快速理解：为了提高工作效率，比如你想在几千万个姓名中寻找一个叫徐瘦婷的人，但是你把这个瘦字忘掉了，用正则表达式可以这样写  </p>

<pre><code>徐.*?婷</code></pre>

<p>这样就可以把所有第一个字为徐，最后一个字为婷的用户列出来，比如：  </p>

<pre><code>徐大婷  
徐小婷  
徐胖婷  
.......</code></pre>

<p>好了，下面整理的一些常用正则表达式的使用语法～  </p>

<h4>一.常用的元字符</h4>

<table>  
<tr>  
<td>代码</td>  
<td>&nbsp;&nbsp;&nbsp;&nbsp;说明</td>  
</tr>   
<tr>  
<td>.</td>  
<td>匹配除换行符以外的任意字符</td>  
</tr>   
<tr>  
<td>\w</td>  
<td>匹配字母或数字或下划线或汉字</td>  
</tr>   
<tr>  
<td>\s</td>  
<td>匹配任意的空白符</td>  
</tr>   
<tr>  
<td>\d</td>  
<td>匹配数字</td>  
</tr>   
<tr>  
<td>\b</td>  
<td>匹配单词的开始或结束（位置）</td>  
</tr>   
<tr>  
<td>^</td>  
<td>匹配字符串的开始（位置）</td>  
</tr>  
<tr>  
<td>$</td>  
<td>匹配字符串的结束（位置）</td>  
</tr>   
<tr>  
<td> ＊ </td>  
<td>指定*前边的内容可以连续重复使用任意次（次数）</td>  
</tr>    
</table>  
  

<p>举几个例子说明一下使用方法：  </p>

<ul>
<li>\b ：&nbsp;&nbsp;是正则表达式规定的一个特殊代码,代表着单词的开头或结尾，也就是单词的分界处。<br/></li>
<li>\d+ ：&nbsp;&nbsp;匹配1个或更多连续的数字。这里的+是和＊类似的元字符，不同的是＊匹配重复任意次(可能是0次)，而+则匹配重复1次或更多次。<br/></li>
<li>\b\w{5}\b ：&nbsp;&nbsp;匹配刚好 5 个字符的单词。<br/></li>
<li>\ba\w * \b ：&nbsp;&nbsp;匹配以字母 a 开头的单词——先是某个单词开始处(\b)，然后是字母 a，然后是任意数量的字母或数字(\w*)，最后是单词结束处(\b)。<br/></li>
<li>0\d\d-\d\d\d\d\d\d\d\d ：&nbsp;&nbsp;匹配这样的字符串：以 0 开头，然后是两个数字，然后是一个连字号 “-”，最后是 8 个数字(也就是电话号码).简写为0\d{2}-\d{8} 。<br/></li>
<li>\bYou\b.*\bHappy\b ：&nbsp;&nbsp;先是匹配一个单词 You，然后是任意个任意字符(但不能是换行)，最后是 Happy 这个单词。<br/></li>
<li>^ \d{5,12}$：&nbsp;&nbsp;要求数字必须为5位到12位。<br/></li>
</ul>

<p><em>注意问题:字符转义</em>  </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp; 如果你想查找元字符本身的话，比如你查找 . 或者 *，就出现了问题：你没办法指定它们，因为它们会被解释成别的意思。这时你就得使用\ 来取消这些字符的特殊意义。因此，你应该使用 \ . 和 \ * 。当然，要查找 \ 本身，你也得用 \。</br>  </p>

<pre><code>例如：unibetter\.com 匹配unibetter.com，C:\\Windows 匹配 C:\Windows</code></pre>

<h4>二.反义字符</h4>

<p>&nbsp;&nbsp;&nbsp;&nbsp;有时需要查找不属于某个能简单定义的字符类的字符。比如想查找除了数字以外，其它任意字符都行的情况，这时需要用到反义：  </p>

<ul>
<li>常用的反义代码<br/></li>
</ul>

<table>  
<tr>  
<td>代码／语法</td>  
<td>&nbsp;&nbsp;&nbsp;&nbsp;说明</td>  
</tr>   
<tr>  
<td>\W</td>  
<td>匹配任意不是字母，数字，下划线，汉字的字符</td>  
</tr>   
<tr>  
<td>\S</td>  
<td>匹配任意不是空白符的字符</td>  
</tr>   
<tr>  
<td>\D</td>  
<td>匹配任意非数字的字符</td>  
</tr>   
<tr>  
<td>\B</td>  
<td>匹配不是单词开头或结束的位置</td>  
</tr>   
<tr>  
<td>[^x]</td>  
<td>匹配除了 x 以外的任意字符</td>  
</tr>   
<tr>  
<td>[^aeiou]</td>  
<td>匹配除了 aeiou 这几个字母以外的任意字符</td>  
</tr>  
</table>  
   

<pre><code>举例：\S+匹配不包含空白符的字符串   
 &lt;a[^&gt;]+&gt; 匹配用尖括号括起来的以 a 开头的字符串。</code></pre>

<h4>三.常用限定符</h4>

<p>1.<strong>重复</strong>  </p>

<table>  
<tr>  
<td>代码</td>  
<td>&nbsp;&nbsp;&nbsp;&nbsp;说明</td>  
</tr>   
<tr>  
<td>＊</td>  
<td>重复零次或多次</td>  
</tr>   
<tr>  
<td>＋</td>  
<td>重复一次或更多次</td>  
</tr>   
<tr>  
<td>s</td>  
<td>匹配任意的空白符</td>  
</tr>   
<tr>  
<td>？</td>  
<td>重复零次会一次</td>  
</tr>   
<tr>  
<td>{n}</td>  
<td>重复n次</td>  
</tr>   
<tr>  
<td>{n,}</td>  
<td> 重复n次或更多次</td>  
</tr>  
<tr>  
<td>$</td>  
<td>匹配字符串的结束（位置）</td>  
</tr>   
<tr>  
<td> {n,m}</td>  
<td>重复n到m次</td>  
</tr>    
</table>  
  

<pre><code>举例说明：load\d+ 匹配 load后面跟 1 个或更多数字  
    ^\w+ 匹配一行(或一个字符串)的第一个单词</code></pre>

<p>2.<strong>分组</strong>（重复多个字符）  </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;举例：(\d{1,3}.){3}\d{1,3} 是一个简单的IP地址匹配表达式。要理解这个表达式，请按下列顺序分析它：  </p>

<pre><code>\d{1,3} 匹配 1 到 3 位的数字，(\d{1,3}\.){3} 匹配三位数字加上一个英文句号(这个整体也就是这个分组)重复 3 次，最后再加上一个一到三位的数字 (\d{1,3})。</code></pre>

<ul>
<li>常用分组语法<br/></li>
</ul>

<table>  
<tr>  
<td>分类 </td>  
<td>代码/语法</td>  
<td>&nbsp;&nbsp;&nbsp;&nbsp;说明</td>  
</tr>   
<tr>  
<td>捕获</td>  
<td>(exp)</td>  
<td>匹配exp,并捕获文本到自动命名的组里</td>  
</tr>   
<tr>  
<td>捕获</td>  
<td>(?< name >exp)</td>  
<td>匹配exp,并捕获文本到名称为name的组里，也可以写成(?’name’exp)  
</td>  
</tr>   
<tr>  
<td>捕获</td>  
<td>(?:exp) </td>  
<td>匹配exp,不捕获匹配的文本，也不给此分组分配组号</td>  
</tr>   
<tr>  
<td>零宽断言</td>  
<td>(?=exp)</td>  
<td>匹配exp前面的位置</td>  
</tr>   
<tr>  
<td>零宽断言</td>  
<td>(?<=exp)</td>  
<td>匹配exp后面的位置</td>  
</tr>   
<tr>  
<td>零宽断言</td>  
<td>(?!exp)</td>  
<td> 匹配后面跟的不是exp的位置</td>  
</tr>  
<tr>  
<td>零宽断言</td>  
<td>(?<=exp)</td>  
<td>匹配前面不是exp的位置</td>  
</tr>   
<tr>  
<td> 注释</td>  
<td>(?#comment)</td>  
<td>这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读</td>  
</tr>    
</table>  
  

<p>(<em>注：零宽断言</em><br/>
&nbsp;&nbsp;&nbsp;&nbsp;像 \b , ^ , $ 那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被称为零宽断言。)</br>  </p>

<p>3.<strong>后向引用</strong>  </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;使用小括号指定一个子表达式后，匹配这个子表达式的文本(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理。  </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;后向引用用于重复搜索前面某个分组匹配的文本。例如，\b(\w+)\b\s+\1\b 可以用来匹配重复的单词，像 go go, 或者 kitty kitty。</br>  </p>

<pre><code>这个表达式首先是一个单词，也就是单词开始处和结束处之间的多于一个的字母或数字 (\b(\w+)\b)，这个单词会被捕获到编号为 1 的分组中，然后是 1 个或几个空白符 (\s+)，最后是分组1中捕获的内容（也就是前面匹配的那个单词）(\1)。&lt;/br&gt;</code></pre>

<p>4.<strong>贪婪与懒惰限定符</strong>  </p>

<ul>
<li><p>贪婪限定符：最长匹配（匹配尽可能多的字符）。  </p>

<pre><code>举例：a.*b，它将会匹配最长的以 a 开始，以 b 结束的字符串。如果用它来搜索 aabab 的话，它会匹配整个字符串 aabab。</code></pre></li>
<li><p>懒惰匹配：最短匹配（匹配尽可能少的字符）。  </p>

<pre><code>举例：a.*?b ，以 a 开始，以 b 结束的字符串。如果把它应用于 aabab的话，它会匹配 aab（第一到第三个字符）和 ab（第四到第五个字符）。</code></pre></li>
<li><p>常用懒惰限定符  </p></li>
</ul>

<table>  
<tr>  
<td>代码/语法</td>  
<td>&nbsp;&nbsp;&nbsp;&nbsp;说明</td>  
</tr>   
<tr>  
<td>*?</td>  
<td>重复1次或更多次，但尽可能少重复  
</td>  
</tr>   
<tr>  
<td>+?</td>  
<td>重复0次或1次，但尽可能少重复  
</td>  
</tr>   
<tr>  
<td>??</td>  
<td>重复n到m次，但尽可能少重复</td>  
</tr>   
<tr>  
<td>{n,m}?</td>  
<td>匹配不是单词开头或结束的位置</td>  
</tr>   
<tr>  
<td>{n,}?</td>  
<td>重复n次以上，但尽可能少重复  
</td>  
</tr>   
</table>  
  

<h4>四.其他常用语法</h4>

<table>  
<tr>  
<td>代码/语法</td>  
<td>&nbsp;&nbsp;&nbsp;&nbsp;说明</td>  
</tr>   
<tr>  
<td>\a</td>  
<td>报警字符(打印它的效果是电脑嘀一声)</td>  
</tr>   
<tr>  
<td>\t</td>  
<td>制表符，Tab</td>  
</tr>   
<tr>  
<td>\r</td>  
<td>回车/td>  
</tr>   
<tr>  
<td>\v</td>  
<td>竖向制表符</td>  
</tr>   
<tr>  
<td>\f</td>  
<td>换页符</td>  
</tr>   
<tr>  
<td>\n</td>  
<td>换行符</td>  
</tr>   
<tr>  
<td>\e</td>  
<td>escape</td>  
</tr>   
<tr>  
<td>\0nn</td>  
<td>ASCII代码中八进制代码为nn的字符  
</td>  
</tr>   
<tr>  
<td>\xnn</td>  
<td>ASCII代码中十六进制代码为nn的字符</td>  
</tr>   
<tr>  
<td>\unnnnr</td>  
<td>Unicode代码中十六进制代码为nnnn的字符</td>  
</tr>   
<tr>  
<td>\G</td>  
<td>当前搜索的开头</td>  
</tr>   
</table>  
  

<p>&nbsp;&nbsp;&nbsp;&nbsp;介绍比较简单，详细用法可参考关于正则表达式语言元素的MSDN在线文档:<a href="https://msdn.microsoft.com/zh-cn/library/az24scfc.aspx">https://msdn.microsoft.com/zh-cn/library/az24scfc.aspx</a>  </p>

<h4>五.补充几个正则表达式编辑器(本小白也没用过，有待进一步探索)：</h4>

<p>Debuggex ：<a href="https://www.debuggex.com/">https://www.debuggex.com/</a></br><br/>
PyRegex：<a href="http://www.pyregex.com/">http://www.pyregex.com/</a></br><br/>
Regexper：<a href="http://www.regexper.com/">http://www.regexper.com/</a></br>  </p>

            ]]>
        </content>
    </entry>
    
</feed>